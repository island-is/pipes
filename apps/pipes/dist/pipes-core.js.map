{"version":3,"file":"pipes-core.js","sources":["../../../libs/zod/src/observer.ts","../../../libs/zod/src/zod.ts","../../../pipes-modules/pipes-module-core/src/create-pipes-context-command.ts","../../../pipes-modules/pipes-module-core/src/create-module.ts","../../../pipes-modules/pipes-module-core/src/pipes-core-module.ts","../../../pipes-modules/pipes-module-core/src/base-class.ts","../src/pipes-core.ts"],"sourcesContent":["import { autorun, createAtom, makeAutoObservable } from \"mobx\";\n\nimport type { IAtom } from \"mobx\";\nimport type { ZodAny, ZodType, z } from \"zod\";\n\nexport class MobXStore {\n  constructor() {\n    makeAutoObservable(this);\n  }\n}\n\ntype StoreObj = Record<string, z.ZodType<any> | Function>;\n\nclass AtomMap {\n  #atom = new Map<string, IAtom>();\n  get(key: string): IAtom {\n    if (!this.#atom.has(key)) {\n      const value = createAtom(key);\n      this.#atom.set(key, value);\n      return value;\n    }\n    return this.#atom.get(key) as IAtom;\n  }\n}\nconst createAtomMap = () => new AtomMap();\n\ninterface Skip<T extends StoreObj, key extends keyof T = keyof T> {\n  key: keyof T;\n  get: () => T[key] extends z.ZodType<any> ? z.infer<T[key]> : T[key];\n  set?: (value: T[key] extends z.ZodType<any> ? z.infer<T[key]> : T[key]) => boolean;\n}\n\ntype Skips<T extends StoreObj> = Skip<T>[];\ntype DefaultOutput<T extends StoreObj> = { [K in keyof T]: T[K] extends z.ZodType<any> ? z.infer<T[K]> : T[K] };\nexport function createZodStore<T extends StoreObj = StoreObj, Output = DefaultOutput<T>>(\n  obj: T,\n  skip: Skips<T> = [],\n): Output {\n  return new (class {\n    /** @ts-expect-error: this is accessed */\n    #values: {\n      [K in keyof T]: ZodType<T[K]> | Function;\n    } = {};\n    constructor() {\n      const observables = createAtomMap();\n      const skipped = skip.map(({ key }) => key);\n\n      for (const { key, get, set } of skip) {\n        // So we can get all keys with Object.keys\n        (this as any)[key] = undefined;\n        Object.defineProperty(this, key, {\n          get,\n          set: set ?? undefined,\n        });\n      }\n      for (const key of Object.keys(obj)) {\n        if (skipped.includes(key)) {\n          continue;\n        }\n        // So we can get all keys with Object.keys\n        (this as any)[key] = true;\n        Object.defineProperty(this, key, {\n          get: () => {\n            observables.get(key).reportObserved();\n            if (typeof this.#values[key] === \"undefined\") {\n              if (typeof obj[key] === \"function\") {\n                this.#values[key as keyof T] = obj[key];\n              } else {\n                this.#values[key as keyof T] = (obj[key] as ZodAny).parse(undefined);\n              }\n            }\n            return this.#values[key];\n          },\n          set: (value) => {\n            if (typeof obj[key] === \"function\") {\n              observables.get(key).reportChanged();\n              this.#values[key as keyof T] = (obj[key] as any)._wrapper(value);\n              return true;\n            }\n            this.#values[key as keyof T] = (obj[key] as ZodAny).parse(value);\n            observables.get(key).reportChanged();\n            return true;\n          },\n        });\n      }\n    }\n  })() as unknown as Output;\n}\n\ntype DefaultWrapOutput<T extends StoreObj> = {\n  [K in keyof T]: T[K] extends z.ZodType<any>\n    ? z.infer<T[K]>\n    : T[K] extends (arg1: any, arg2: any, ...arg: infer Arg) => infer X\n    ? Arg[\"length\"] extends 0 | undefined\n      ? () => X\n      : (arg: Arg[0]) => X\n    : T[K] extends (arg1: any, arg2: any) => infer X\n    ? () => X\n    : T[K];\n};\n\nexport const wrapContext = <T extends Record<string, any>, Output = DefaultWrapOutput<T>>(\n  obj: T,\n  config: Record<string, any>,\n  stack: string[] = [config.appName],\n): Output => {\n  const functionParams = Object.entries(obj).filter(([_key, value]) => typeof value === \"function\");\n  const skip = [\n    { key: \"stack\", get: () => stack },\n    ...functionParams.map(([key, value]) => {\n      return {\n        key,\n        get: () => {\n          return (val: any) => {\n            const newContext = wrapContext(obj, config, [...stack, key]);\n            return (value as Function)(newContext, config, val);\n          };\n        },\n      };\n    }),\n  ];\n  return new (class {\n    /** @ts-expect-error: this is accessed */\n    #values: { [K in keyof T]: valueToZod<T[K]> } = {};\n    constructor() {\n      const skipped = skip.map(({ key }) => key);\n\n      for (const { key, get } of skip) {\n        // So we can get all keys with Object.keys\n        (this as any)[key] = undefined;\n        Object.defineProperty(this, key, {\n          get,\n        });\n      }\n      for (const key of Object.keys(obj)) {\n        if (skipped.includes(key)) {\n          continue;\n        }\n        // So we can get all keys with Object.keys\n        (this as any)[key] = true;\n        Object.defineProperty(this, key, {\n          get: () => {\n            return obj[key];\n          },\n          set: (value) => {\n            obj[key as keyof T] = value;\n            return true;\n          },\n        });\n      }\n    }\n  })() as unknown as Output;\n};\n\nexport const createLockStore = (): {\n  isLocked: (key: string) => boolean;\n  waitForLock: (key: string) => Promise<void>;\n  lock<T extends () => any>(key: string, fn: T): Promise<Awaited<ReturnType<T>>>;\n} => {\n  return new (class {\n    #atom = createAtomMap();\n    #map = new Map<string, boolean>();\n    #lockKey = (key: string) => {\n      this.#map.set(key, true);\n      this.#atom.get(key).reportChanged();\n    };\n    #unlock = (key: string) => {\n      this.#map.set(key, false);\n      this.#atom.get(key).reportChanged();\n    };\n    isLocked(key: string): boolean {\n      this.#atom.get(key).reportObserved();\n      return this.#map.has(key) ? this.#map.get(key) === true : false;\n    }\n    waitForLock(key: string): Promise<void> {\n      return new Promise<void>((resolve) => {\n        const fn: Record<string, () => void> = {};\n        fn.stopWait = autorun(() => {\n          this.#atom.get(key).reportObserved();\n          const isLocked = this.isLocked(key);\n          if (!isLocked) {\n            resolve();\n            if (!fn.stopWait) {\n              return;\n            }\n            fn.stopWait();\n          }\n        });\n      });\n    }\n    async lock<T extends () => any>(key: string, fn: T): Promise<Awaited<ReturnType<T>>> {\n      await this.waitForLock(key);\n      this.#lockKey(key);\n      let value: Awaited<ReturnType<T>>;\n      try {\n        value = await fn();\n      } catch (e) {\n        this.#unlock(key);\n        throw e;\n      }\n\n      this.#unlock(key);\n      return value;\n    }\n  })();\n};\n\nexport const createZodKeyStore = <T extends z.ZodType<any>>(\n  type: T,\n): {\n  awaitForAvailability(key: string): Promise<z.infer<T>>;\n  getKey(key: string): Promise<z.infer<T> | null>;\n  setKey(key: string, value: z.infer<T>): Promise<void>;\n  getOrSet(key: string, fn: () => Promise<z.infer<T>> | z.infer<T>): Promise<z.infer<T>>;\n} => {\n  return new (class {\n    #type: T;\n    #atom = createAtomMap();\n    #map = new Map<string, z.infer<T>>();\n    #lock = createLockStore();\n    constructor() {\n      this.#type = type;\n    }\n    awaitForAvailability(key: string): Promise<z.infer<T>> {\n      return new Promise((resolve) => {\n        const fn: Record<string, () => void> = {};\n        fn.stopWaiting = autorun(async () => {\n          this.#atom.get(key).reportObserved();\n          const value = await this.getKey(key);\n          if (value !== null) {\n            resolve(value);\n            if (!fn.stopWaiting) {\n              return;\n            }\n            fn.stopWaiting();\n          }\n        });\n      });\n    }\n    async getKey(key: string): Promise<z.infer<T> | null> {\n      const value = await this.#lock.lock(key, () => {\n        this.#atom.get(key).reportObserved();\n        return !this.#map.has(key) ? null : this.#map.get(key);\n      });\n      return value;\n    }\n    async setKey(key: string, value: z.infer<T>): Promise<void> {\n      await this.#lock.lock(key, () => {\n        this.#map.set(key, this.#type.parse(value));\n        this.#atom.get(key).reportChanged();\n      });\n    }\n    async getOrSet(key: string, fn: () => Promise<z.infer<T>> | z.infer<T>): Promise<z.infer<T>> {\n      const value = await this.#lock.lock(key, async () => {\n        if (!this.#map.has(key)) {\n          const newValue = await fn();\n          this.#atom.get(key).reportChanged();\n          this.#map.set(key, newValue);\n          return newValue;\n        }\n        this.#atom.get(key).reportObserved();\n        return this.#map.get(key);\n      });\n      return value as T | null;\n    }\n  })();\n};\n\nconst globalstore = {} as any;\nconst globalLock = createLockStore();\n\nexport const createGlobalZodStore = <T extends StoreObj>(\n  obj: T,\n  key: string,\n): Promise<ReturnType<typeof createZodStore<T>>> => {\n  return globalLock.lock(key, () => {\n    if (globalstore[key]) {\n      return globalstore[key] as ReturnType<typeof createZodStore<T>>;\n    }\n\n    globalstore[key] = createZodStore<T>(obj);\n    return globalstore[key] as ReturnType<typeof createZodStore<T>>;\n  });\n};\n\nexport const createGlobalZodKeyStore = <T extends z.ZodType<any>>(\n  obj: T,\n  key: string,\n): Promise<ReturnType<typeof createZodKeyStore<T>>> => {\n  return globalLock.lock(key, () => {\n    if (globalstore[key]) {\n      return globalstore[key] as ReturnType<typeof createZodKeyStore<T>>;\n    }\n    globalstore[key] = createZodKeyStore<T>(obj);\n    return globalstore[key] as ReturnType<typeof createZodKeyStore<T>>;\n  });\n};\n","import { parseArgs } from \"node:util\";\n\nimport { ZodType, z } from \"zod\";\n\nimport type { ZodDefault, ZodTypeAny, util } from \"zod\";\n\ninterface DefaultProps {\n  env?: string;\n  variables?: string;\n  arg?: {\n    short?: string | undefined;\n    long: string;\n    positional?: boolean;\n  };\n}\ndeclare module \"zod\" {\n  // We need to type augmented methods, so we leave them as they are.\n  // eslint-disable-next-line no-shadow, unused-imports/no-unused-vars\n  interface ZodType<Output = any, Def extends z.ZodTypeDef = z.ZodTypeDef, Input = Output> {\n    default(def?: util.noUndefined<Input>, options?: DefaultProps): ZodDefault<this>;\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    default(def?: () => util.noUndefined<Input>, options?: DefaultProps): ZodDefault<this>;\n  }\n}\n\nconst ZodTypes = [\"string\", \"number\", \"boolean\", \"literal\"] as const;\n\nconst getMostInnerZodType = <prev extends null | \"array\" | \"union\">(\n  schema: ZodTypeAny,\n  prev: prev = null as prev,\n): (typeof ZodTypes)[number] | `array:${(typeof ZodTypes)[number]}` | `union:literal` => {\n  // Check if the current schema has an innerType\n\n  if (schema instanceof z.ZodString) {\n    return \"string\";\n  }\n  if (schema instanceof z.ZodNumber) {\n    return \"number\";\n  }\n  if (schema instanceof z.ZodBoolean) {\n    return \"boolean\";\n  }\n  if (schema instanceof z.ZodLiteral) {\n    return \"literal\";\n  }\n  if (schema instanceof z.ZodArray) {\n    return `array:${getMostInnerZodType(schema._def.type, \"array\")}` as `array:${(typeof ZodTypes)[number]}`;\n  }\n  if (schema instanceof z.ZodUnion) {\n    return `union:literal`;\n  }\n  const inner = (schema as any)._def?.innerType;\n  if (inner) {\n    return getMostInnerZodType(inner);\n  }\n\n  throw new Error(\"Not implemented yet for env\");\n};\n\nconst oldDefault = ZodType.prototype.default;\n\nconst getArgv = (context: ZodType<any, any, any>, options: DefaultProps | undefined) => {\n  if (\n    options === undefined || // Arg overwrites env\n    options.arg === undefined\n  ) {\n    return null;\n  }\n\n  const fn = oldDefault.bind(context);\n  const zodType = getMostInnerZodType(context);\n  const argOptions = {\n    type: zodType === \"boolean\" || zodType === \"array:boolean\" ? (\"boolean\" as const) : (\"string\" as const),\n    multiple: zodType.startsWith(\"array:\"),\n  };\n  if (options.arg.short !== undefined) {\n    (argOptions as unknown as { short: string }).short = options.arg.short;\n  }\n  const { values, positionals } = parseArgs({\n    args: process.argv.slice(2),\n    options: {\n      [options.arg.long]: argOptions,\n    },\n    allowPositionals: true,\n    strict: false,\n  });\n\n  const value = (() => {\n    if (options.arg?.positional && positionals.length !== 0) {\n      return positionals;\n    }\n    return values[options.arg.long];\n  })();\n\n  if (value != undefined) {\n    switch (zodType) {\n      case \"string\":\n      case \"literal\":\n      case `union:literal`:\n        if (Array.isArray(value)) {\n          return fn(value[0]);\n        }\n        return fn(value);\n\n      case \"number\":\n        if (Array.isArray(value)) {\n          return fn(Number(value[0]));\n        }\n        return fn(Number(value));\n\n      case \"boolean\":\n        if (Array.isArray(value)) {\n          return fn(value[0]);\n        }\n        return fn(value);\n\n      case `array:string`:\n      case `array:literal`:\n        if (Array.isArray(value)) {\n          return fn(value);\n        }\n        if (typeof value === \"string\") {\n          return fn(value.split(\",\"));\n        }\n        return fn(undefined);\n      case `array:number`:\n        if (Array.isArray(value) && value.every((v) => !Number.isNaN(Number(v)))) {\n          return fn(value.map(Number));\n        }\n        if (typeof value === \"string\") {\n          return fn(value.split(\",\").map(Number));\n        }\n        return fn(undefined);\n\n      case `array:boolean`:\n        return fn(value);\n\n      default:\n        throw new Error(`Not implemented yet for this type ${zodType}`);\n    }\n  }\n  return null;\n};\n\nconst getEnv = (context: ZodType<any, any, any>, options: DefaultProps | undefined) => {\n  if (options === undefined || options.env === undefined) {\n    return null;\n  }\n\n  const fn = oldDefault.bind(context);\n  const value = process.env[options.env];\n  if (value !== undefined) {\n    const zodType = getMostInnerZodType(context);\n    switch (zodType) {\n      case \"string\":\n      case `union:literal`:\n      case \"literal\":\n        return fn(value);\n\n      case \"number\":\n        return fn(Number(value));\n\n      case \"boolean\":\n        return fn(value === \"true\");\n\n      case `array:string`:\n        return fn(value.split(\",\"));\n\n      case `array:number`:\n        return fn(value.split(\",\").map(Number));\n\n      case `array:boolean`:\n        return fn(value.split(\",\").map((v) => v === \"true\"));\n\n      default:\n        throw new Error(`Not implemented yet for this type ${zodType}`);\n    }\n  }\n  return null;\n};\n\n/** @ts-expect-error - Patching */\nZodType.prototype.default = function (def, options) {\n  const fn = oldDefault.bind(this);\n\n  return getArgv(this, options) || getEnv(this, options) || fn(def);\n};\n\nexport * from \"zod\";\nexport * from \"./observer.js\";\n","/**\n * @file Create functions for context commands.\n */\n\nimport { z } from \"@island.is/zod\";\n\nimport type { Module, ModuleConfig, ModuleConfigValue, ModuleContext, ModuleContextInterface } from \"./types/module.js\";\nimport type { PipesContextCommand } from \"./types/pipes-command.js\";\nimport type { valueToZod } from \"./types/value-to-zod.js\";\n\nexport const createPipesContextCommand = <\n  BaseModule extends Module<any, any, any, any, any, any>,\n  Value = undefined,\n  Output = undefined,\n  _BaseContext extends ModuleContext<any, any, any> = BaseModule[\"Context\"],\n  BaseContext extends ModuleContextInterface<BaseContext> = _BaseContext[\"ContextInterface\"],\n  _BaseConfig extends ModuleConfig<any, any, any> = BaseModule[\"Config\"],\n  BaseConfig extends ModuleConfigValue<BaseConfig> = _BaseConfig[\"Merged\"],\n  ValueSchema extends valueToZod<Value> | undefined = undefined extends Value ? undefined : valueToZod<Value>,\n  OutputSchema extends valueToZod<Output> = valueToZod<Output>,\n>({\n  value = undefined as any,\n  output = z.void() as any,\n  implement,\n}: {\n  value?: ValueSchema;\n  output?: OutputSchema;\n  implement: (context: BaseContext, config: BaseConfig, _value: Value) => Output;\n}): PipesContextCommand<BaseModule, Value, Output> => {\n  // Skip validating context and config\n  const configSchema = z.custom<BaseConfig>();\n  const contextSchema = z.custom<BaseContext>();\n  const _fn = (__fn: typeof implement) => {\n    if (value === undefined) {\n      return z\n        .function()\n        .args(contextSchema.describe(\"Context\"), configSchema.describe(\"Config\"))\n        .returns(output)\n        .implement(__fn as any);\n    }\n    return z\n      .function()\n      .args(contextSchema.describe(\"Context\"), configSchema.describe(\"Config\"), value)\n      .returns(output)\n      .implement(__fn as any);\n  };\n  const __fn = _fn(implement);\n  const fn: ReturnType<typeof __fn> = (...args: Parameters<typeof __fn>) => {\n    // We will add debug and stuff later.\n    return fn._fn(...args);\n  };\n  const wrapper: ReturnType<typeof __fn> = (newFn: typeof implement) => _fn(newFn);\n  (fn as unknown as PipesContextCommand<BaseModule, Value, Output>)._wrapper = wrapper;\n  (fn as unknown as PipesContextCommand<BaseModule, Value, Output>)._implement = _fn;\n  (fn as unknown as PipesContextCommand<BaseModule, Value, Output>)._fn = __fn;\n  (fn as unknown as PipesContextCommand<BaseModule, Value, Output>)._isPipesCommand = true;\n  return fn as unknown as PipesContextCommand<BaseModule, Value, Output>;\n};\n","/**\n * @file Create Pipes Context Module\n */\nimport { z } from \"@island.is/zod\";\n\nimport { createPipesContextCommand } from \"./create-pipes-context-command.js\";\n\nimport type {\n  AnyModule,\n  CreateModule,\n  ModuleConfigValue,\n  ModuleName,\n  moduleNameToString,\n  newModuleName,\n} from \"./types/module.js\";\n\nexport function createModuleName<T extends string>(name: T): T {\n  return name;\n}\n\nexport function createConfig<Module extends AnyModule, ConfigImplement = Module[\"Config\"][\"Implement\"]>(\n  fn: (prop: { z: typeof z }) => ConfigImplement,\n): (prop: { z: typeof z }) => ConfigImplement {\n  return fn;\n}\n\nexport function createContext<Module extends AnyModule, ContextImplement = Module[\"Context\"][\"Implement\"]>(\n  fn: (prop: {\n    z: typeof z;\n    fn: <Value = undefined, Output = undefined>(\n      props: Parameters<typeof createPipesContextCommand<Module, Value, Output>>[0],\n    ) => ReturnType<typeof createPipesContextCommand<Module, Value, Output>>;\n  }) => ContextImplement,\n): typeof fn {\n  return fn;\n}\n\nexport const _createModule = <\n  NewModule extends AnyModule,\n  ConfigImplement = NewModule[\"Config\"][\"Implement\"],\n  ContextImplement = NewModule[\"Context\"][\"Implement\"],\n  RequiredNames extends ModuleName[] = NewModule[\"RequiredModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : moduleNameToString<NewModule[\"RequiredModules\"][number][\"ModuleName\"]>[],\n  OptionalNames extends ModuleName[] = NewModule[\"OptionalModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : moduleNameToString<NewModule[\"OptionalModules\"][number][\"ModuleName\"]>[],\n>({\n  name,\n  config,\n  context,\n  required = [] as unknown as RequiredNames,\n  optional = [] as unknown as OptionalNames,\n}: {\n  name: moduleNameToString<NewModule[\"ModuleName\"]>;\n  config: (value: { z: typeof z }) => ConfigImplement;\n  context: (value: {\n    z: typeof z;\n    fn: <Value = undefined, Output = undefined>(\n      props: Parameters<typeof createPipesContextCommand<NewModule, Value, Output>>[0],\n    ) => ReturnType<typeof createPipesContextCommand<NewModule, Value, Output>>;\n  }) => ContextImplement;\n  required?: RequiredNames;\n  optional?: OptionalNames;\n}): {\n  name: NewModule[\"ModuleName\"];\n  config: ConfigImplement;\n  context: ContextImplement;\n  required: RequiredNames;\n  optional: OptionalNames;\n} => {\n  const fn = <Value = undefined, Output = undefined>(\n    props: Parameters<typeof createPipesContextCommand<NewModule, Value, Output>>[0],\n  ) => createPipesContextCommand<NewModule, Value, Output>(props);\n  return {\n    name,\n    config: config({ z }),\n    context: context({ z, fn }),\n    required: required.map((e) => createModuleName(e)) as RequiredNames,\n    optional: optional.map((e) => createModuleName(e)) as OptionalNames,\n  };\n};\n\n// NOTICE: We reintroduce alot of typing here so modules can be safely isolated.\nexport function createModule<\n  NewModule extends AnyModule,\n  ConfigImplement = NewModule[\"Config\"][\"Implement\"],\n  ContextImplement = NewModule[\"Context\"][\"Implement\"],\n  RequiredNames extends ModuleName[] = NewModule[\"RequiredModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : moduleNameToString<NewModule[\"RequiredModules\"][number][\"ModuleName\"]>[],\n  OptionalNames extends ModuleName[] = NewModule[\"OptionalModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : moduleNameToString<NewModule[\"OptionalModules\"][number][\"ModuleName\"]>[],\n>(param: {\n  name: moduleNameToString<NewModule[\"ModuleName\"]>;\n  config: (value: { z: typeof z }) => ConfigImplement;\n  context: (value: {\n    z: typeof z;\n    fn: <Value = undefined, Output = undefined>(\n      props: Parameters<typeof createPipesContextCommand<NewModule, Value, Output>>[0],\n    ) => ReturnType<typeof createPipesContextCommand<NewModule, Value, Output>>;\n  }) => ContextImplement;\n  required?: RequiredNames;\n  optional?: OptionalNames;\n}): {\n  name: NewModule[\"ModuleName\"];\n  config: ConfigImplement;\n  context: ContextImplement;\n  required: RequiredNames;\n  optional: OptionalNames;\n} {\n  return _createModule<NewModule, ConfigImplement, ContextImplement, RequiredNames, OptionalNames>(param);\n}\nexport type createModuleDef<\n  Name extends string,\n  Definition,\n  Config extends ModuleConfigValue<Config>,\n  RequiredModules extends AnyModule[] = [],\n  OptionalModules extends AnyModule[] = [],\n> = CreateModule<newModuleName<Name>, Definition, Config, RequiredModules, OptionalModules>;\n","/* eslint-disable no-shadow */\n/**\n * @file Core module for pipes\n */\nimport { Client, Container } from \"@dagger.io/dagger\";\nimport { createGlobalZodKeyStore } from \"@island.is/zod\";\nimport ciinfo from \"ci-info\";\n\n// eslint-disable-next-line sort-imports\nimport { createConfig, createContext, createModule as _createModule } from \"./create-module.js\";\n\nimport type { createModuleDef as _createModuleDef } from \"./create-module.js\";\nimport type { AnyModule, ModuleName, moduleNameToString } from \"./types/module.js\";\nimport type { createZodKeyStore, z } from \"@island.is/zod\";\n\ninterface IPipesCoreContext {\n  client: Client;\n  haltAll: () => void;\n  modules: ModuleName[];\n  stack: string[];\n  hasModule: <Module extends AnyModule>(name: moduleNameToString<Module[\"ModuleName\"]>) => boolean;\n  imageStore: Promise<ReturnType<typeof createZodKeyStore<z.ZodType<Container>>>>;\n  addEnv: (prop: { container: Container; env: [string, string][] }) => Container;\n}\n\ninterface IPipesCoreConfig {\n  appName: string;\n  isCI: boolean;\n  isPR: boolean;\n  env: \"github\" | \"gitlab\" | \"local\";\n}\n\nexport type PipesCoreModule = _createModuleDef<\"PipesCore\", IPipesCoreContext, IPipesCoreConfig>;\n\nconst PipesCoreConfig = createConfig<PipesCoreModule>(({ z }) => ({\n  appName: z.string().default(\"pipes\").describe(\"The name of the context\"),\n  env: z\n    .union([z.literal(\"github\"), z.literal(\"gitlab\"), z.literal(\"local\")])\n    .default(() => {\n      if (ciinfo.GITLAB) {\n        return \"gitlab\";\n      }\n      if (ciinfo.GITHUB_ACTIONS) {\n        return \"github\";\n      }\n      return \"local\";\n    })\n    .describe(\"The environment the code is running in\"),\n  isCI: z\n    .boolean()\n    .default(ciinfo.isCI, {\n      env: \"ci\",\n      arg: {\n        long: \"isCI\",\n        short: \"c\",\n      },\n    })\n    .describe(\"Is the current environment a CI environment\"),\n  isPR: z\n    .boolean()\n    .default(ciinfo.isPR || false)\n    .describe(\"Is the current environment a PR environment\"),\n}));\n\nconst PipesCoreContext = createContext<PipesCoreModule>(({ z, fn }): PipesCoreModule[\"Context\"][\"Implement\"] => ({\n  haltAll: fn<undefined, undefined>({\n    implement: () => {},\n  }),\n  addEnv: fn<{ container: Container; env: [string, string][] }, Container>({\n    output: z.custom<Container>(),\n    value: z.object({ container: z.custom<Container>(), env: z.array(z.tuple([z.string(), z.string()])) }),\n    implement: (_context, _config, { container, env }) => {\n      let newContainer = container;\n      for (const [key, value] of env) {\n        newContainer = newContainer.withEnvVariable(key, value);\n      }\n      return newContainer;\n    },\n  }),\n  modules: z.array(z.string()).default([]).describe(\"The modules to load\"),\n  stack: z.array(z.string()).default([]).describe(\"The caller stack\"),\n  imageStore: z.custom<Promise<ReturnType<typeof createZodKeyStore<z.ZodType<Container>>>>>(() => {\n    return createGlobalZodKeyStore(\n      z.custom<Container>((val) => {\n        if (val instanceof Container) {\n          return val;\n        }\n        throw new Error(\"Invalid value\");\n      }),\n      \"PIPES-IMAGE-STORE\",\n    );\n  }),\n  client: z.custom<Client>((val) => {\n    if (val instanceof Client) {\n      return val;\n    }\n    throw new Error(\"Provided client is not an instance of the expected Client class.\");\n  }),\n  hasModule: fn<string, boolean>({\n    output: z.boolean(),\n    value: z.string(),\n    implement: (context, _config, value) => {\n      return context.modules.includes(value as any);\n    },\n  }),\n}));\n\nexport const PipesCore: {\n  name: PipesCoreModule[\"ModuleName\"];\n  config: PipesCoreModule[\"Config\"][\"Implement\"];\n  context: PipesCoreModule[\"Context\"][\"Implement\"];\n} = _createModule<PipesCoreModule>({\n  name: \"PipesCore\",\n  config: PipesCoreConfig,\n  context: PipesCoreContext,\n});\n","import { Client, Container } from \"@dagger.io/dagger\";\nimport { createGlobalZodKeyStore, createZodStore, wrapContext, z } from \"@island.is/zod\";\n\nimport { PipesCore, type PipesCoreModule } from \"./pipes-core-module.js\";\n\nimport type { AnyModule, MergeModules, ModuleName } from \"./types/module.js\";\nimport type { PipesContextCommandBase } from \"./types/pipes-command.js\";\nimport type { Simplify } from \"./types/simplify.js\";\n\n/**\n * Represents the core class for contexts and modules.\n * @class\n */\nexport class PipesCoreClass<\n  Modules extends AnyModule[] = [PipesCoreModule],\n  CurrentState extends MergeModules<Modules> = MergeModules<Modules>,\n  CurrentConfig extends CurrentState[\"Config\"] = CurrentState[\"Config\"],\n  CurrentContext extends CurrentState[\"Context\"] = CurrentState[\"Context\"],\n  ScriptFn extends fn<CurrentContext[\"ContextInterface\"], CurrentConfig[\"Merged\"]> = fn<\n    CurrentContext[\"ContextInterface\"],\n    CurrentConfig[\"Merged\"]\n  >,\n> {\n  /**\n   * A private array to store scripts.\n   * @private\n   */\n  #scripts: ScriptFn[] = [];\n\n  /**\n   * Adds a new script to the core.\n   */\n  addScript(fn: ScriptFn): this {\n    this.#scripts.push(fn);\n    return this as any;\n  }\n  #haltAll: () => void = () => {};\n  set haltAll(value: () => void | Promise<void>) {\n    this.#haltAll = value;\n  }\n  get haltAll(): () => void {\n    return this.#haltAll;\n  }\n  /**\n   * Private state management related to the readiness and modules of the core.\n   */\n  #internalStatesStore: State_Internal = {\n    modules: [\"PipesCoreModule\" as ModuleName],\n    isReady: {\n      state: \"NOT_READY\",\n      reason: \"Dagger Client has not been injected\",\n    },\n  };\n  #internalStates = new Proxy(this.#internalStatesStore, {\n    set: (target, prop: keyof State_Internal & \"client\", value) => {\n      if (prop === \"client\") {\n        if (value && value instanceof Client) {\n          (target as any).client = value;\n          target.isReady.state = \"READY\";\n          delete (target.isReady as any).reason;\n          return true;\n        } else {\n          delete (target as any).client;\n          target.isReady.state = \"NOT_READY\";\n          (target.isReady as any).reason = \"Dagger Client has not been injected\";\n        }\n        return true;\n      }\n      return false;\n    },\n  });\n\n  // Private Zod schemas to parse configurations and contexts.\n  #configSchema: CurrentState[\"Config\"][\"MergedImplement\"];\n  #contextSchema: CurrentState[\"Context\"][\"MergedImplement\"];\n\n  // Public instances for config and context.\n  config: CurrentConfig[\"Merged\"];\n  context: {\n    // Functions have WEIRD typing on purpose so they don't get easily overwritten\n    // but we want them to be overwritten here, since the proxy handles it correctly.\n    // eslint-disable-next-line max-len\n    [key in keyof CurrentContext[\"OutsideInterface\"]]: CurrentContext[\"OutsideInterface\"][key] extends PipesContextCommandBase\n      ? Diff<CurrentContext[\"OutsideInterface\"][key], PipesContextCommandBase>\n      : CurrentContext[\"OutsideInterface\"][key];\n  };\n\n  constructor({\n    modules,\n    schemas: { config, context },\n  }: {\n    modules: ModuleName[];\n    schemas: {\n      config: CurrentConfig[\"MergedImplement\"];\n      context: CurrentContext[\"MergedImplement\"];\n    };\n  }) {\n    this.#internalStatesStore.modules = modules;\n\n    this.#configSchema = config;\n    this.#contextSchema = context;\n    this.config = createZodStore<typeof config, CurrentConfig[\"Merged\"]>(this.#configSchema);\n    this.context = createZodStore<typeof context, CurrentContext[\"OutsideInterface\"]>(this.#contextSchema, [\n      {\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        key: \"imageStore\" as const,\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        get: () => {\n          return createGlobalZodKeyStore(\n            z.custom<Container>((val: unknown) => {\n              if (val instanceof Container) {\n                return val;\n              }\n              throw new Error(\"Invalid value\");\n            }),\n            \"PIPES-IMAGE-STORE\",\n          );\n        },\n      },\n      {\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        key: \"haltAll\" as const,\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        get: () => {\n          return this.haltAll;\n        },\n      },\n      {\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        key: \"client\",\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        get: () => {\n          return this.client;\n        },\n      },\n      {\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        key: \"modules\",\n        /** @ts-expect-error - For simplification this is not hardcoded into the generic. */\n        get: () => {\n          return this.modules;\n        },\n      },\n    ]);\n  }\n\n  // Public getter to check if the core is ready.\n  get isReady(): boolean {\n    return this.#internalStates.isReady.state === \"READY\";\n  }\n\n  // Public getter to fetch the current modules.\n  get modules(): ModuleName[] {\n    return this.#internalStates.modules;\n  }\n\n  /**\n   * Method to check if a specific module is present.\n   */\n  hasModule(moduleName: string): boolean {\n    return this.modules.includes(moduleName);\n  }\n\n  /**\n   * Method to add a new module to the core.\n   */\n  addModule<T extends AnyModule>(module: ModuleReturnType<T>): PipesCoreClass<[T, ...Modules]> {\n    if (this.isReady) {\n      throw new Error(`Cannot add module when in ready state`);\n    }\n    const requiredModules = module.required ?? [];\n    for (const requiredModule of requiredModules) {\n      if (!this.hasModule(requiredModule)) {\n        throw new Error(`Missing required module ${requiredModule}`);\n      }\n    }\n    const newConfigSchema = {\n      ...this.#configSchema,\n      ...module.config,\n    };\n    const newContextSchema = {\n      ...this.#contextSchema,\n      ...module.context,\n    };\n    const modules = [...this.modules, module.name];\n    return new PipesCoreClass<[T, ...Modules]>({\n      modules,\n      schemas: { config: newConfigSchema, context: newContextSchema },\n    });\n  }\n\n  // Setter/getter for client\n  set client(client: Client) {\n    (this.#internalStates as any).client = client;\n  }\n  get client(): Client {\n    if (!this.isReady) {\n      throw new Error(\"Client not ready\");\n    }\n    return (this.#internalStates as any).client;\n  }\n\n  // Method to run all the scripts stored in the core.\n  async run(): Promise<void> {\n    if (this.#internalStates.isReady.state === \"NOT_READY\") {\n      throw new Error(this.#internalStates.isReady.reason);\n    }\n    const context = wrapContext<typeof this.context, CurrentContext[\"ContextInterface\"]>(this.context, this.config);\n    await Promise.all(\n      this.#scripts.map(async (fn) => {\n        const value = await fn(context, this.config);\n        return value;\n      }),\n    );\n  }\n}\n\n/**\n * Factory function to create a new instance of the `PipesCoreClass`.\n */\nexport const createPipesCore = (): PipesCoreClass<[PipesCoreModule]> => {\n  const core = new PipesCoreClass<[PipesCoreModule]>({\n    modules: [PipesCore.name],\n    schemas: {\n      config: PipesCore.config,\n      context: PipesCore.context,\n    },\n  });\n  return core;\n};\n\n/**\n * Type guard that checks if context has module\n */\nexport const ContextHasModule = <T extends any, K extends keyof T, Context extends Partial<T>>(\n  context: unknown,\n  key: K,\n): context is Simplify<Required<Pick<Context, keyof T>> & Omit<Context, keyof T>> => {\n  return !!(context && typeof context === \"object\" && key in context);\n};\n\n/**\n * Type guard that checks if config has module\n */\nexport const ConfigHasModule = <T extends any, K extends keyof T, Config extends Partial<T>>(\n  config: unknown,\n  key: K,\n): config is Simplify<Required<Pick<Config, keyof T>> & Omit<Config, keyof T>> => {\n  return !!(config && typeof config === \"object\" && key in config);\n};\n\n// Helper types.\ntype ModuleReturnType<NewModule extends AnyModule> = {\n  name: NewModule[\"ModuleName\"];\n  config: NewModule[\"Config\"][\"Implement\"];\n  context: NewModule[\"Context\"][\"Implement\"];\n  required: NewModule[\"RequiredModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : NewModule[\"RequiredModules\"][number][\"ModuleName\"][];\n  optional: NewModule[\"OptionalModules\"][number][\"ModuleName\"] extends never\n    ? []\n    : NewModule[\"OptionalModules\"][number][\"ModuleName\"][];\n};\n\ntype State_IsPipeCoreReady<T = any> = T extends {\n  state: \"READY\" | \"NOT_READY\";\n  reason?: string | undefined | null;\n}\n  ? T[\"state\"] extends \"READY\"\n    ? { state: \"READY\" }\n    : { state: \"NOT_READY\"; reason: string }\n  : never;\ntype State_Internal<T extends any = any> = T extends {\n  client?: Client | undefined | null;\n  isReady: State_IsPipeCoreReady;\n  modules: ModuleName[];\n}\n  ? T[\"isReady\"][\"state\"] extends \"READY\"\n    ? { client: Client; modules: ModuleName[]; isReady: State_IsPipeCoreReady<{ state: \"READY\" }> }\n    : T[\"isReady\"][\"state\"] extends \"NOT_READY\"\n    ? { modules: ModuleName[]; isReady: State_IsPipeCoreReady<{ state: \"NOT_READY\" }> }\n    : never\n  : never;\n\ntype fn<Context extends any, Config extends any> = (context: Context, config: Config) => Promise<void> | void;\ntype Diff<T, U> = T extends any & U ? (T extends infer R & U ? R : never) : never;\n","import { connect } from \"@dagger.io/dagger\";\nimport {\n  ConfigHasModule,\n  ContextHasModule,\n  createConfig,\n  createContext,\n  createModule,\n  createPipesCore,\n} from \"@island.is/pipes-module-core\";\nimport { createGlobalZodKeyStore, createZodStore, wrapContext, z } from \"@island.is/zod\";\n\nimport type { Client } from \"@dagger.io/dagger\";\nimport type { PipesCoreClass, PipesCoreModule, Simplify, createModuleDef } from \"@island.is/pipes-module-core\";\n\nexport class PipesCoreRunner {\n  #context: Set<PipesCoreClass> = new Set();\n\n  addContext(value: PipesCoreClass): () => void {\n    this.#context.add(value);\n    return () => {\n      this.removeContext(value);\n    };\n  }\n  removeContext(value: PipesCoreClass): void {\n    this.#context.delete(value);\n  }\n  async run(): Promise<void> {\n    await connect(\n      async (client: Client) => {\n        const _haltObj: { halt?: (value: string) => Promise<void> | void } = {};\n        const halt = () => {\n          if (_haltObj.halt) {\n            void _haltObj.halt(\"Forced quit\");\n          } else {\n            process.exit(1);\n          }\n        };\n        const fakePromise = new Promise<void>((_resolve, reject) => {\n          _haltObj.halt = reject;\n        });\n        for (const context of this.#context) {\n          context.client = client;\n          context.haltAll = halt;\n        }\n        const contextPromises = await Promise.all(\n          Array.from(this.#context).map(async (value) => {\n            await value.run();\n          }),\n        );\n        await Promise.race([fakePromise, contextPromises]);\n      },\n      { LogOutput: process.stdout },\n    );\n  }\n}\n\ninterface CreatePipeProps {\n  z: typeof z;\n  createPipesCore: typeof createPipesCore;\n  createConfig: typeof createConfig;\n  createModule: typeof createModule;\n  createContext: typeof createContext;\n  contextHasModule: typeof ContextHasModule;\n  configHasModule: typeof ConfigHasModule;\n}\n\ninterface PipeBase {\n  run: () => Promise<any> | any;\n  client: Client | null | undefined;\n}\n\nexport const createPipe = async (\n  // eslint-disable-next-line no-shadow\n  fn: ({ z, createPipesCore }: CreatePipeProps) => Promise<PipeBase[]> | PipeBase[],\n): Promise<void> => {\n  const core = new PipesCoreRunner();\n  const values = await fn({\n    z,\n    createPipesCore,\n    createConfig,\n    createContext,\n    createModule,\n    contextHasModule: ContextHasModule,\n    configHasModule: ConfigHasModule,\n  });\n  for (const value of values) {\n    // If we define this better we get circular errors…\n    core.addContext(value as PipesCoreClass);\n  }\n  await core.run();\n};\n\nexport {\n  createConfig,\n  createContext,\n  createModule,\n  z,\n  PipesCoreClass,\n  createZodStore,\n  createGlobalZodKeyStore,\n  wrapContext,\n};\nexport type { createModuleDef, PipesCoreModule, Simplify };\nexport * from \"@dagger.io/dagger\";\n"],"names":["AtomMap","Map","get","key","has","value","createAtom","set","createAtomMap","createZodStore","obj","skip","constructor","observables","skipped","map","undefined","Object","defineProperty","keys","includes","reportObserved","parse","reportChanged","_wrapper","wrapContext","config","stack","appName","functionParams","entries","filter","_key","val","newContext","createLockStore","isLocked","waitForLock","Promise","resolve","fn","stopWait","autorun","lock","e","createZodKeyStore","type","awaitForAvailability","stopWaiting","getKey","setKey","getOrSet","newValue","globalstore","globalLock","createGlobalZodKeyStore","getMostInnerZodType","schema","prev","z","ZodString","ZodNumber","ZodBoolean","ZodLiteral","ZodArray","_def","ZodUnion","inner","innerType","Error","oldDefault","ZodType","prototype","default","getArgv","context","options","arg","bind","zodType","argOptions","multiple","startsWith","short","values","positionals","parseArgs","args","process","argv","slice","long","allowPositionals","strict","positional","length","Array","isArray","Number","split","every","v","isNaN","getEnv","env","def","createPipesContextCommand","output","void","implement","configSchema","custom","contextSchema","_fn","__fn","function","describe","returns","wrapper","newFn","_implement","_isPipesCommand","createModuleName","name","createConfig","createContext","_createModule","required","optional","props","createModule","param","PipesCoreConfig","string","union","literal","ciinfo","GITLAB","GITHUB_ACTIONS","isCI","boolean","isPR","PipesCoreContext","haltAll","addEnv","object","container","array","tuple","_context","_config","newContainer","withEnvVariable","modules","imageStore","Container","client","Client","hasModule","PipesCore","PipesCoreClass","addScript","push","isReady","state","reason","Proxy","target","prop","schemas","moduleName","addModule","module","requiredModules","requiredModule","newConfigSchema","newContextSchema","run","all","createPipesCore","core","ContextHasModule","ConfigHasModule","PipesCoreRunner","Set","addContext","add","removeContext","delete","connect","_haltObj","halt","exit","fakePromise","_resolve","reject","contextPromises","from","race","LogOutput","stdout","createPipe","contextHasModule","configHasModule"],"mappings":"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"}